//  Задача 1
  Promise.reject("a") // 1) создали промис, который сразу отклоняется со значением "а". Имеем промис в состоянии rejected со значением "а"
    .catch((p) => p + "b", console.log(5989)) // 2) Поскольку промис отклонен выполняем первый catch. Внутри значение "a"(передано в параметр "р"). Суммируем "а" + "b" = "ab". Промис перешел в состояние fulfilled с результатом "ab"
    .catch((p) => p + "c", console.log(598898889)) // 3) Из-за того,что в п.2 промис перешел в состояние fulfilled данный catch игнорируется. 
    .then((p) => p + "d") // 4) Промис в состоянии fulfilled поэтому выполняется .then. В параметре "р" теперь "ab", "ab" + "d" = "abd". Промис переходит в состояние fulfilled с результатом "abd"
    .then((p) => p + "f") // 5) Т.к. в п.4 промис находится в состоянии fulfilled, то и данный .then тоже выполнится. В "p" находится "abd". "abd" + "f" = "abdf".Промис переходит в состояние fulfilled с результатом "abd"
    .catch((p) => p + "h") // 6) Т.к. в п.5 промис перешел в состояние fulfilled, то данный catch игнорируется
    .finally((p) => p + "e") // 7) Метод .finally выполняется всегда, независимо от того, был ли промис выполнен или отклонен.Однако важно помнить, что .finally не изменяет результат промиса. Он просто выполняет код внутри себя.
    .then((p) => console.log(p));

//   Задача 2

  console.log("1");

  setTimeout(() => console.log("2"), 1);

  let promise = new Promise((resolve) => {
    console.log("3");
    resolve();
  });
  promise.then(() => console.log("4"));
  setTimeout(() => console.log("5"));
  console.log("6");

  console.log(1, 3, 6, 4, 5, 2);



let promise1 = new Promise(function(resolve, reject) {
    // эта функция выполнится автоматически, при вызове new Promise
  
    // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
    setTimeout(() => resolve(console.log("done")), 1000);
  });